<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="./polymer-sortable.html">

<dom-module id="polymer-sortable-bound">
  <script>
    (function() {

     function _filter (nodes, selector) {
        if (!(nodes instanceof NodeList || nodes instanceof HTMLCollection || nodes instanceof Array)) {
            throw new Error('You must provide a nodeList/HTMLCollection/Array of elements to be filtered.');
        }
        if (typeof selector !== 'string') {
            return Array.from(nodes);
        }
        return Array.from(nodes).filter(function (item) { return item.nodeType === 1 && item.matches(selector); });
    }
    /**
     * ## PolymerSortableBound
     *
     * `<polymer-sortable-bound>` Allow use of html5-sortable on dom-repeat to be bound with external data store (e.g. firebase)
     *
     * @memberof PolymerEl
     * @customElement
     * @polymer
     * @demo
     **/
    class PolymerSortableBound extends PolymerEl.PolymerSortable {

      static get is() {
        return 'polymer-sortable-bound';
      }

      static get properties() {
        return {
          /*
           * `data` data bound to the list
           */
           data: {
             type: Object,
             notify: true
           },

           /*
            * `keyPath` path to the key
            */
            keyPath: {
              type: String,
              value: 'key'
              },

            /*
            * `indexPath` path to the index
            */
            indexPath: {
              type: String,
              value: 'index'
              },

            getIndex: {
              type: Function, 
              computed: '_compteGetIndex(indexPath)'
            },

            /*
             * `delegateAdd` when true, only rely on `sortable-add-item` event
             * to delegate adding item to containers
             */
             delegateAdd: {
               type: Boolean,
               value: true
            },

            /*
             * `targetSelectorFilter` selector that will filter nodes on target
             */
            targetSelectorFilter: {
              type: String,
              value: '*'
            },

        };
      }
      
      _compteGetIndex(indexPath) {
        return function(item) {
          return Polymer.Path.get(item, indexPath) * 1;
        };
      }

      swapItem(repeater, index, oldindex, model, event) {
        this._resetRepeaterDom(repeater, index, oldindex);
        this._translateItems(index, oldindex);
        this.set(`data.${this.get(this.keyPath, model)}.${this.indexPath}`, index);
        this._resetIndex();
        // const items = repeater.items.concat();
        this.dispatchEvent(new CustomEvent('sortable-item-swap', {detail: {
          repeater: repeater,
          origin: event.detail && event.detail.origin,
          destination: event.detail && event.detail.destination,
          model: model,
          index: index,
          oldindex: oldindex
        }, bubbles: true, composed: true}));
      }

      // addToRepeater(repeater, index, oldindex, model, event, key) {
      //     delete(model[this.keyPath]); 
      //     if(!this.data || Object.keys(this.data).length === 0) {
      //       this.data = {[key]: model};
      //     } else {
      //       this.set(`data.${key}`, model);
      //     }
      //     super.addItem(...arguments);
      //     this._translateItems(repeater.items, index, Infinity);
      //     this._resetIndex();
      // }

      addItem(repeater, index, oldindex, model, event) {
        const key = this.get(this.keyPath, model);

        // Note(cg): when dropping from another repeater adding item should happen
        // while listeneing `sortable-item-add`.
        // if (key && repeater != this && !this.delegateAdd) {
        // if (key || (repeater != this && !this.delegateAdd)) {
          // this.addToRepeater(repeater, index, oldindex, model, event, key);
        // }
        this._translateItems(index, Infinity);

        // this._resetIndex();
        this.dispatchEvent(new CustomEvent('sortable-item-add', {detail: {
          repeater: repeater,
          delegateAdd: this.delegateAdd,
          origin: event.detail && event.detail.origin,
          destination: event.detail && event.detail.destination,
          model: model,
          index: index,
          oldindex: oldindex, 
          key: key,
        }, bubbles: true, composed: true}));
      }

      removeItem(repeater, index, oldindex, model, event, copy) {
        return super.removeItem(...arguments)
          .then( () => {
            if(copy) {
              return;
            }
            const key = this.get(this.keyPath, model);
            const startparent = event.detail.origin && event.detail.origin.container;
            if(startparent && startparent._translateItems) {
              startparent._translateItems(Infinity, oldindex);
              startparent._resetIndex();
            }
            // Note(cg): is is the repeated dipatching the event as 
            // it is really where it happens. We still need to remove 
            // at storage level
            repeater.dispatchEvent(new CustomEvent('sortable-item-remove', {detail: {
              repeater: repeater,
              origin: event.detail && event.detail.origin,
              destination: event.detail && event.detail.destination,
              model: model,
              index: index,
              oldindex: oldindex,
              copy: copy,
              key: key
            }, bubbles: true, composed: true}));
          })
      }

      _translateItems(index, oldindex) {
        const data = this.data || {};
        Object.keys(data).forEach(key => {
          const item = data[key];
          const itemIndex = this.getIndex(item); // Polymer.Path.get(item, this.indexPath) * 1;
          if (itemIndex >= index && itemIndex < oldindex) {
            // item[this.indexPath] = itemIndex + 1;
            this.set(`data.${key}.${this.indexPath}`, itemIndex + 1);
          } else if (itemIndex <= index && itemIndex > oldindex) {
            // item[this.indexPath] = itemIndex - 1;
            this.set(`data.${key}.${this.indexPath}`, itemIndex - 1);
          }
        });
      }

      _resetIndex() {
        const data = this.data || {};
        Object.keys(data ).sort((ka, kb) => {
          const indexa = this.getIndex(data[ka]);
          const indexb = this.getIndex(data[kb]);
          if(indexa > indexb) {
            return 1;
          }
          if(indexa < indexb) {
            return -1;
          }
          return 0;
        }).forEach((key,index) => {
          this.set(`data.${key}.${this.indexPath}`, index);
        })
      }

      // Note(cg): we re-order dom nodes as they have been swapped during drop operation 
      // and are not in sync with dom-repeat.__instances.
      _resetRepeaterDom(repeater, index, oldindex) {
        const parent = repeater.parentElement
        const node = parent.children[index];
        const targetIndex = index > oldindex ? oldindex : oldindex + 1
        const target = parent.children[targetIndex]
        parent.insertBefore(node,target);

      }

      _getNewIndex(parent, item, event) {
        // The index returned by the event, are not correct because it excludes those which are not selectable
        return [].indexOf.call(_filter(parent.children, this.targetSelectorFilter), item);
      }
    }

    customElements.define(PolymerSortableBound.is, PolymerSortableBound);

    if (!window.PolymerEl) {
      window.PolymerEl = {};
    }

   /*
    * @namespace MultiChart
    */
    window.PolymerEl.PolymerSortableBound = PolymerSortableBound;

    })();
  </script>
</dom-module>