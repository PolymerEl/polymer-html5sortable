<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="polymer-html5sortable-script.html">
<!--

# polymer-html5sortable

[Polymer](https://www.polymer-project.org/) wrapper for [html5sortable](https://github.com/lukasoppermann/html5sortable) library.

## Demo
[https://trofrigo.github.io/polymer-html5sortable/](https://trofrigo.github.io/polymer-html5sortable/)

## Using the element

This element must be placed always as a `parentNode` of a `dom-repeat` template.
```
<html5-sortable>
    <template is="dom-repeat"
              items="[[ items ]]">

    </template>
</html5-sortable>
```


### Basic list

```
<ul>
    <html5-sortable>
        <template is="dom-repeat"
                  items="[[ items ]]">
            <li>[[ item ]]</li>
        </template>
    </html5-sortable>
</ul>
```

### Linked lists

```
<!-- var listItems = ['Item 1', 'Item 2', 'Item 3'] - ->
<ul id="list">
    <html5-sortable connect-with="connectedlist">
        <template is="dom-repeat"
                  items="[[ listItems ]]">
            <li>[[ item ]]</li>
        </template>
    </html5-sortable>
</ul>


<!-- var gridItems = ['1', '2', '3'] - ->
<div id="grid">
    <html5-sortable connect-with="connectedlist">
        <template is="dom-repeat"
                  items="[[ gridItems ]]">
            <li>[[ item ]]</li>
        </template>
    </html5-sortable>
</div>
```

Note: Under the hood, the `<html5-sortable>` element will move the value from the original
array to the new one every time you drag an element. After that, `dom-repeat` elements will
notice the splices and rerender the lists. This functionality allows you to have your application
model synchronized and ready to be used.

### Infinite sortable tree (nested lists)


```

<!-- Defining the tree node element - ->

<dom-module id="sortable-tree">
    <template>
        [[ rootNode.label ]]
        <ul>
            <html5-sortable connect-with="sortable-tree"
                            style="min-height: 10px;">
                <template is="dom-repeat"
                          items="[[ rootNode.children ]]">
                    <li>
                        <sortable-tree root-node="[[ item ]]">
                    </li>
                </template>
            </html5-sortable>
        </ul>
    </template>
    <script>
        Polymer({
            is: 'sortable-tree',
            properties : {
                rootNode: Object
            }
        });
    </script>
</dom-module>
```
Note: In order to be able to drag elements into an empty children array,
the `html5-sortable` element that surrounds the array's dom-repeat,
must have a minimum height.

```
<!-- Defining the tree model - ->
var tree = {
    label : 'node 1',
    children: [
        {
            label: 'node 1.1',
            children: []
        },
        {
            label: 'node 1.2',
            children: [
                {
                    label: 'node 1.2.1',
                    children: []
                },
                {
                    label: 'node 1.2.2',
                    children: []
                },
            ]
        },
        {
            label: 'node 1.3',
            children: []
        },
    ]
};
```

Showing the tree

```
<sortable-tree root-node="[[ tree ]]"></sortable-tree>

```


@demo demo/index.html
-->
<dom-module id="polymer-sortable">
  <template>
    <style>
    :host {
      display: block;
      min-height: 48px;
    }
    </style>
    <slot></slot>
  </template>
  <script>
  (function() {

    /**
     * ## PolymerSortable
     *
     * `<polymer-sortable>` [Polymer](https://www.polymer-project.org/) wrapper for [Sortable](https://github.com/lukasoppermann/Sortable) library.
     *
     * @memberof PolymerEl
     * @customElement
     * @polymer
     * @demo
     **/
    class PolymerSortable extends Polymer.Element {

      static get is() {
        return 'polymer-sortable';
      }

      static get properties() {
        return {
          /** Use items option to specify which items inside the element should be sortable */
          items: String,
          /** Use handle option to restrict drag start to the specified element */
          handle: String,
          /** Setting forcePlaceholderSize option to true, forces the placeholder to have a height */
          forcePlaceholderSize: {
            type: Boolean,
            value: false
          },

          /*
           * `acceptFrom` Use the acceptFrom option to restrict which sortable's items
           * will be accepted by this sortable.
           * acceptFrom accepts a space separated list of selectors or false to disabling
           * accepting items. This is an alternative to connectWith and should not be used together.
           *
           * sortable('.sortable', {
           *   acceptFrom: '.selector,.anotherSortable' // Defaults to null
           * });
           *
           */
          acceptFrom: {
            type: String,
          },

          /*
           * `copy` Use the copy option to duplicate the element on drag. The original element will remain in the same position.
           */
          copy: {
            type: Boolean,
            value: false
          },

          /** Use placeholder option to specify the markup of the placeholder. Example `<tr><td colspan="7">&nbsp;</td></tr>` */
          placeholder: String,
          /** Use hoverClass option to specify applying a css class to the hovered element rather than relying on :hover. This can eliminate some potential drag and drop issues where another element thinks it is being hovered over. */
          hoverClass: String,
          /** Use placeholderClass option to specify applying a css class to the placeholder element.*/
          placeholderClass: String,
          /** Use draggingClass option to specify applying a css class to the dragging element.*/
          draggingClass: String,

          /*
           * `parentClass` class applied to parent of this element
           */
          parentClass: {
            type: String
          },

          /** User disabled option to prevent an a list to be reordered or modified.*/
          disabled: {
            type: Boolean,
            value: false,
            observer: '_onDisabledChanged'
          },

          /*
           * `transformModel` a function for tranforming model when we drop from another list
           */
          transformModel: {
            type: Function,
            value: function() {
              return function(model, event) {
                return model;
              };
            }
          },

          /*
           * `avoidDuplicate` true to avoid same model to be adde multiple time under the same list
           */
          avoidDuplicate: {
            type: Boolean,
            value: false
          },
        };
      }


      connectedCallback() {

        super.connectedCallback();
        Polymer.RenderStatus.afterNextRender(this, () => {
          const repeater = this._getRepeater(this);
          repeater.mutableData = true;
          repeater.addEventListener('dom-change', () => {
            // Reloading the sortable every time that dom-repeat changes
            this.init();
          });
          this.addEventListener('sortstart', this._onSortstart);
          this.addEventListener('sortupdate', this._onSortupdate);
          this.addEventListener('sortstop', this._onSortstop);
          this.init();
        });
      }

      disconnectedCallback() {
        this.destroy();
        super.disconnectedCallback();
      }

      init() {
        const config = {};

        // Adding config
        ['items', 'handle', 'forcePlaceholderSize', 'acceptFrom', 'copy', 'placeholder', 'hoverClass', 'placeholderClass', 'draggingClass', 'parentClass']
        .forEach(key => {
          const value = this.get(key);
          if (value !== undefined) {
            config[key] = value;
          }
        });

        // Adding custom children selector function
        config.getChildren = function(element) {
          return element.children.filter(child => {
            return child.localName !== 'dom-repeat';
          });
        };

        this.sortable = sortable(this, config);
      }

      destroy() {
        if (this.sortable) {
          sortable(this, 'destroy');
          delete this.sortable;
        }
      }

      _onDisabledChanged(newValue, oldValue) {
        if (this.sortable) {
          if (newValue === false) {
            sortable(this, 'enable');
          } else {
            sortable(this, 'disable');
          }
        }
      }
      _onSortstart(event) {
        event.stopPropagation();
        if (this.parentClass) {
          this.parentElement.classList.add(this.parentClass);
        }
        this.dispatchEvent(new CustomEvent('sort-start', { detail: event, bubbles: true, composed: true }));
      }

      _onSortstop(event) {
        event.stopPropagation();
        if (this.parentClass) {
          this.parentElement.classList.remove(this.parentClass);
        }
        this.dispatchEvent(new CustomEvent('sort-stop', {
          detail: event,
          bubbles: true,
          composed: true
        }));
      }

      /**
       * This callback is called every time that an element is moved, inside of a list or from one one to another
       * @param event
       * @private
       */
      _onSortupdate(event) {
        event.stopPropagation();
        const item = event.detail.item,
          startparent = event.detail.origin && event.detail.origin.container,
          startrepeater = this._getRepeater(startparent),
          endparent = event.detail.destination && event.detail.destination.container,
          endrepeater = this._getRepeater(endparent);

        const modelIndex = this._getModelAndIndex(startrepeater, item, event, startparent.copy);
        const model = modelIndex.model;

        // The index returned by the event, are not correct because it excludes those which are no selectable
        const index = [].indexOf.call(endparent.children, item);
        // const oldindex = startrepeater.indexForElement(item);
        const oldindex = modelIndex.index;
        console.info('model', modelIndex, index);

        // Note(cg): we need to remove item from endparent to avoid node duplication 
        // and messing up with indexses
        if (item.parentElement === endparent) {
          endparent.removeChild(item);
        }

        if (endparent === this && startparent === this) {
          // Moving the element to this new index
          this.swapItem(endrepeater, startparent.copy ? index - 1 : index, oldindex, model, event);
        } else if (endparent === this) {
          this.addItem(endrepeater, index, oldindex, model, event);
          this.removeItem(startrepeater, index, oldindex, model, event, startparent.copy);
        }

        this.dispatchEvent(new CustomEvent('sort-update', {
          detail: event,
          bubbles: true,
          composed: true
        }));
      }

      _getModelAndIndex(repeater, item, event, copy) {
        if (copy) {
          const items = repeater.items.concat();
          if (repeater.__sortFn) {
            items.sort((a, b) => repeater.__sortFn(items[a], items[b]));
          }
          const model = items[event.detail.origin.index];
          return {
            model: model,
            index: items.indexOf(model)
          };
        }
        return {
          model: repeater.itemForElement(item),
          index: repeater.indexForElement(item)
        };
      }

      swapItem(repeater, index, oldindex, model, event) {
        const items = repeater.items;
        const item = items[oldindex];
        items[oldindex] = items[index];
        items[index] = item;
        repeater.items = [];
        Polymer.RenderStatus.afterNextRender(this, () => {
          repeater.items = items;
          console.info(items);
        });
        // repeater.splice('items', index, 0, startrepeater.splice('items', oldindex, 1)[0]);
      }

      addItem(repeater, index, oldindex, model, event) {
        // Note(cg): we add one option for transforming model.
        model = this.transformModel(model, event);
        if (this._checkDuplicate(repeater, model)) {
          repeater.splice('items', Math.max(index, 0), 0, model);
        }
      }

      // Note(cg): when startrepeater is `copy`, we can add multiple time the same item.
      // This method allows to avoid that
      _checkDuplicate(repeater, model) {
        if (this.avoidDuplicate) {
          return repeater.items.indexOf(model) < 0;
        }
        return true;
      }

      removeItem(repeater, index, oldindex, model, event, copy) {
        if (copy) {
          repeater.notifyPath('items');
          // repeater.items.splice(oldindex, 1);
        } else {
          // Note(cg): hack for forcing refresh. As htmlo5sortable is modifing the dom,
          // we cannot rely on `items` mutation:
          //   startrepeater.items.splice(oldindex, 1);
          //   startrepeater.initialCount = Math.max(startrepeater.items.length - 1, 0);
          //   startrepeater.__render();
          const items = repeater.items;
          repeater.items = [];
          items.splice(items.indexOf(model), 1);
          Polymer.RenderStatus.afterNextRender(this, () => {
            repeater.items = items;
          });
        }

      }

      _getChildren(node) {
        return [].filter.call(node.children, function(child) {
          return child.localName !== 'dom-repeat';
        });
      }

      _getRepeater(node) {
        return [].filter.call(node.children, child => {
          return child.localName === 'dom-repeat';
        })[0];
      }
    }

    customElements.define(PolymerSortable.is, PolymerSortable);

    if (!window.PolymerEl) {
      window.PolymerEl = {};
    }

    /*
     * @namespace MultiChart
     */
    window.PolymerEl.PolymerSortable = PolymerSortable;

  })();
  </script>
</dom-module>