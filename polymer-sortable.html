<link rel="import" href="../polymer/polymer.html">
<!-- <link rel="import" href="polymer-html5sortable-script.html"> -->
<link rel="import" href="polymer-html5sortable-script-dev.html">
<link rel="import" href="placeholder-mixin.html">
<!--

# polymer-html5sortable

[Polymer](https://www.polymer-project.org/) wrapper for [html5sortable](https://github.com/lukasoppermann/html5sortable) library.

## Demo
[https://trofrigo.github.io/polymer-html5sortable/](https://trofrigo.github.io/polymer-html5sortable/)

## Using the element

This element must be placed always as a `parentNode` of a `dom-repeat` template.
```
<html5-sortable>
    <template is="dom-repeat"
              items="[[ items ]]">

    </template>
</html5-sortable>
```


### Basic list

```
<ul>
    <html5-sortable>
        <template is="dom-repeat"
                  items="[[ items ]]">
            <li>[[ item ]]</li>
        </template>
    </html5-sortable>
</ul>
```

### Linked lists

```
<!-- var listItems = ['Item 1', 'Item 2', 'Item 3'] - ->
<ul id="list">
    <html5-sortable connect-with="connectedlist">
        <template is="dom-repeat"
                  items="[[ listItems ]]">
            <li>[[ item ]]</li>
        </template>
    </html5-sortable>
</ul>


<!-- var gridItems = ['1', '2', '3'] - ->
<div id="grid">
    <html5-sortable connect-with="connectedlist">
        <template is="dom-repeat"
                  items="[[ gridItems ]]">
            <li>[[ item ]]</li>
        </template>
    </html5-sortable>
</div>
```

Note: Under the hood, the `<html5-sortable>` element will move the value from the original
array to the new one every time you drag an element. After that, `dom-repeat` elements will
notice the splices and rerender the lists. This functionality allows you to have your application
model synchronized and ready to be used.

### Infinite sortable tree (nested lists)


```

<!-- Defining the tree node element - ->

<dom-module id="sortable-tree">
    <template>
        [[ rootNode.label ]]
        <ul>
            <html5-sortable connect-with="sortable-tree"
                            style="min-height: 10px;">
                <template is="dom-repeat"
                          items="[[ rootNode.children ]]">
                    <li>
                        <sortable-tree root-node="[[ item ]]">
                    </li>
                </template>
            </html5-sortable>
        </ul>
    </template>
    <script>
        Polymer({
            is: 'sortable-tree',
            properties : {
                rootNode: Object
            }
        });
    </script>
</dom-module>
```
Note: In order to be able to drag elements into an empty children array,
the `html5-sortable` element that surrounds the array's dom-repeat,
must have a minimum height.

```
<!-- Defining the tree model - ->
var tree = {
    label : 'node 1',
    children: [
        {
            label: 'node 1.1',
            children: []
        },
        {
            label: 'node 1.2',
            children: [
                {
                    label: 'node 1.2.1',
                    children: []
                },
                {
                    label: 'node 1.2.2',
                    children: []
                },
            ]
        },
        {
            label: 'node 1.3',
            children: []
        },
    ]
};
```

Showing the tree

```
<sortable-tree root-node="[[ tree ]]"></sortable-tree>

```


@demo demo/index.html
-->
<dom-module id="polymer-sortable">
  <template>
    <style>
    :host {
      display: block;
      min-height: 32px;
    }

    </style>
    <slot></slot>
  </template>
  <script>
  (function() {

    /**
     * ## PolymerSortable
     *
     * `<polymer-sortable>` [Polymer](https://www.polymer-project.org/) wrapper for [Sortable](https://github.com/lukasoppermann/Sortable) library.
     *
     * @memberof PolymerEl
     * @customElement
     * @polymer
     * @demo
     **/
    class PolymerSortable extends Polymer.Element {

      static get is() {
        return 'polymer-sortable';
      }

      static get properties() {
        return {
          /** Use items option to specify which items inside the element should be sortable */
          items: String,
          /** Use handle option to restrict drag start to the specified element */
          handle: String,
          /** Setting forcePlaceholderSize option to true, forces the placeholder to have a height */
          forcePlaceholderSize: {
            type: Boolean,
            value: false
          },

          /*
           * `acceptFrom` Use the acceptFrom option to restrict which sortable's items
           * will be accepted by this sortable.
           * acceptFrom accepts a space separated list of selectors or false to disabling
           * accepting items. This is an alternative to connectWith and should not be used together.
           *
           * sortable('.sortable', {
           *   acceptFrom: '.selector,.anotherSortable' // Defaults to null
           * });
           *
           */
          acceptFrom: {
            type: String
          },

          /*
           * `copy` Use the copy option to duplicate the element on drag. The original element will remain in the same position.
           */
          copy: {
            type: Boolean,
            value: false
          },

          /** Use placeholder option to specify the markup of the placeholder. Example `<tr><td colspan="7">&nbsp;</td></tr>` */
          placeholder: String,
          /** Use hoverClass option to specify applying a css class to the hovered element rather than relying on :hover. This can eliminate some potential drag and drop issues where another element thinks it is being hovered over. */
          hoverClass: String,
          /** Use placeholderClass option to specify applying a css class to the placeholder element.*/
          placeholderClass: String,
          /** Use draggingClass option to specify applying a css class to the dragging element.*/
          draggingClass: String,

          /*
           * `parentClass` class applied to parent of this element
           */
          parentClass: {
            type: String
          },

          /*
           * `parentClasscontainerClass` class applied to container when drag hover
           */
          containerClass: {
            type: String
          },

          /** User disabled option to prevent an a list to be reordered or modified.*/
          disabled: {
            type: Boolean,
            value: false,
            observer: '_onDisabledChanged'
          },

          /*
           * `transformModel` a function for tranforming model when we drop from another list
           */
          transformModel: {
            type: Function,
            value: function() {
              return function(model, event) {
                return model;
              };
            }
          },

          /*
           * `getSortable` allow to instantiate sortable on more than 
           * one parent element. For instance it can be used in the context
           * of paper-sublist where sub items should also be sortable
           */
          getSortable: {
            type: Function,
            value: function() {
              return function(polymerSortable) {
                return polymerSortable;
              };
            }
          },

          /*
           * `avoidDuplicate` true to avoid same model to be adde multiple time under the same list
           */
          avoidDuplicate: {
            type: Boolean,
            value: false
          },

          /*
           * `name` allow to give a name to this sortable. It reflects to attributes 
           * so as to be able to set `accept-from="[name=thisName]"`. Class attributes 
           * is sometimes not reliable enough, eg. paper-list,
           */
          name: {
            type: String,
            reflectToAttribute: true
          },

          /*
           * `draggedModel` the model associated with dragged element
           */
          draggedModel: {
            type: Object
          },
          /*
           * `draggedIndex` the index associated with dragged element
           */
          draggedIndex: {
            type: Number
          }
        };
      }


      connectedCallback() {

        super.connectedCallback();
        Polymer.RenderStatus.afterNextRender(this, () => {
          const repeater = this._getRepeater(this);
          repeater.mutableData = true;
          repeater.addEventListener('dom-change', () => {
            this.init()
            // Reloading the sortable every time that dom-repeat changes
          });
          this.addEventListener('sortstart', this._onSortstart);
          this.addEventListener('sortupdate', this._onSortupdate);
          this.addEventListener('sortenter', this._onSortenter);
          this.addEventListener('sortstop', this._onSortstop);
          this.init();
        });
      }

      disconnectedCallback() {
        this.destroy();
        super.disconnectedCallback();
      }

      init() {
        this._debounceInit = Polymer.Debouncer.debounce(
          this._debounceInit,
          Polymer.Async.timeOut.after(100),
          () => {
            const config = {};

            // Adding config
            ['items', 'handle', 'forcePlaceholderSize', 'acceptFrom', 'copy', 'placeholder', 'hoverClass', 'placeholderClass', 'draggingClass', 'containerClass', 'parentClass']
            .forEach(key => {
              const value = this.get(key);
              if (value !== undefined) {
                config[key] = value;
              }
            });

            let sortables = this.getSortable(this);
            // if the user provided an element, return it in an array to keep the return value consistant
            if (sortables instanceof HTMLElement) {
              sortables = [sortables];
            }
            sortables = Array.prototype.slice.call(sortables);
            // Note(cg): we store this polymer-sortable for each sortable parent. 
            sortables.forEach(s => s.__sortable = this);
            this.sortable = sortable(sortables, config);
          });
      }

      destroy() {
        if (this.sortable) {
          sortable(this, 'destroy');
          delete this.sortable;
        }
      }

      _onDisabledChanged(newValue, oldValue) {
        if (this.sortable) {
          if (newValue === false) {
            sortable(this, 'enable');
          } else {
            sortable(this, 'disable');
          }
        }
      }

      // Note(cg): we use this event to store model (dom-repeat item) hold by the dragged item.
      _onSortstart(event) {
        event.stopPropagation();
        if (this.parentClass) {
          this.parentElement.classList.add(this.parentClass);
        }
        const startparent = event.detail.origin && event.detail.origin.container,
          startrepeater = this._getRepeater(startparent);

        this.draggedModel = startrepeater.itemForElement(event.detail.originalTarget);
        this.draggedIndex = startrepeater.indexForElement(event.detail.originalTarget);

        // Note(cg): when we use a handle, originalTarget is the handle itself
        // and not the initial dragged item
        if (!this.draggedModel && event.detail.originalTarget.domHost) {
          this.draggedModel = startrepeater.itemForElement(event.detail.originalTarget.domHost);
          this.draggedIndex = startrepeater.indexForElement(event.detail.originalTarget.domHost);
        }

        // Note(cg): we pass this as event.detail.origin. This is usefull for instance when we have to 
        // fetch draggedModel 
        if (event.detail.origin) {
          event.detail.origin.sortable = this;
        }
        this._dispatch('sort-start', event);

      }

      _onSortenter(event) {
        event.stopPropagation();
        // only if different container
        if (event.detail.origin && event.detail.origin.container !== this) {
          this._dispatch('sort-enter', event);
        }
      }

      _onSortstop(event) {
        event.stopPropagation();
        if (this.parentClass) {
          this.parentElement.classList.remove(this.parentClass);
        }

        this._dispatch('sort-stop', event);
      }

      /**
       * This callback is called every time that an element is moved, inside of a list or from one one to another
       * @param event
       * @private
       */
      _onSortupdate(event) {
        event.stopPropagation();
        const item = event.detail.item,
          startparent = event.detail.origin && event.detail.origin.container,
          startrepeater = this._getRepeater(startparent),
          endparent = event.detail.destination && event.detail.destination.container,
          endrepeater = this._getRepeater(endparent);

        const index = this._getNewIndex(endparent, item, event);
        // const modelIndex =  this._getModelAndIndex(startrepeater, item, event, startparent.copy);
        // const oldindex = modelIndex.index;

        const model = startparent.draggedModel;
        const oldindex = startparent.draggedIndex;
        console.info('model', model, oldindex, index);

        // Note(cg): we need to remove item from endparent to avoid node duplication 
        // and messing up with indexses

        if (endparent === this && startparent === this) {
          // Moving the element to this new index
          this.swapItem(endrepeater, startparent.copy ? index - 1 : index, oldindex, model, event);
        } else if (endparent === this) {
          if (item.parentElement === endparent) {
            endparent.removeChild(item);
          }
          const removeModel = Object.assign({}, model); // Note(cg): we need to copy the model as key might be altered on addItem.
          this.addItem(endrepeater, index, oldindex, model, event);
          this.removeItem(startrepeater, index, oldindex, removeModel, event, startparent.copy || (startparent.__sortable && startparent.__sortable.copy));
        }

        this._dispatch('sort-update', event);
        this.draggedModel = null;
        this.draggedIndex = null;

      }

      _getNewIndex(parent, item, event) {
        // The index returned by the event, are not correct because it excludes those which are not selectable
        return [].indexOf.call(parent.children, item);
      }

      // _getModelAndIndex(repeater, item, event, copy) {
      //   if (copy) {
      //     const items = repeater.items.concat();
      //     if (repeater.__sortFn) {
      //       items.sort((a, b) => repeater.__sortFn(items[a], items[b]));
      //     }
      //     const model = items[event.detail.origin.index];
      //     return {
      //       model: model,
      //       index: items.indexOf(model)
      //     };
      //   }
      //   return {
      //     model: repeater.itemForElement(item),
      //     index: repeater.indexForElement(item)
      //   };
      // }

      swapItem(repeater, index, oldindex, model, event) {
        const items = repeater.items;
        const item = items[oldindex];
        items[oldindex] = items[index];
        items[index] = item;
        repeater.items = [];
        Polymer.RenderStatus.afterNextRender(this, () => {
          repeater.items = items;
          console.info(items);
        });
        // repeater.splice('items', index, 0, startrepeater.splice('items', oldindex, 1)[0]);
      }

      addItem(repeater, index, oldindex, model, event) {
        // Note(cg): we add one option for transforming model.
        model = this.transformModel(model, event);
        if (model && this._checkDuplicate(repeater, model)) {
          // Note(cg): we add the first item.
          if (!repeater.items || !repeater.items.length) {
            model.index = 0;
            repeater.items = [model];
            // repeater.set('items', [model]);
            return;
          }
          repeater.splice('items', Math.max(index, 0), 0, model);
        }

      }

      // Note(cg): when startrepeater is `copy`, we can add multiple time the same item.
      // This method allows to avoid that
      _checkDuplicate(repeater, model) {
        if (this.avoidDuplicate && repeater.items) {
          return repeater.items.indexOf(model) < 0;
        }
        return true;
      }
      // function sleep (time) {
      //      return new Promise((resolve) => setTimeout(resolve, time));
      //   }

      removeItem(repeater, index, oldindex, model, event, copy) {
        return new Promise((resolve) => {
          if (copy) {
            repeater.notifyPath('items');
            return resolve();
            // repeater.items.splice(oldindex, 1);
          } else {
            // Note(cg): hack for forcing refresh. As htmlo5sortable is modifing the dom,
            // we cannot rely on `items` mutation:
            //   startrepeater.items.splice(oldindex, 1);
            //   startrepeater.initialCount = Math.max(startrepeater.items.length - 1, 0);
            //   startrepeater.__render();
            const items = repeater.items;
            repeater.items = [];
            items.splice(items.indexOf(model), 1);
            Polymer.RenderStatus.afterNextRender(this, () => {
              repeater.items = items;
              return resolve();
            });
          }
        });

      }

      _dispatch(name, event) {
        this.dispatchEvent(new CustomEvent(name, {
          detail: Object.assign({
            draggedModel: this.draggedModel,
            draggedIndex: this.draggedIndex
          }, event.detail),
          bubbles: true,
          composed: true
        }));
      }

      _getRepeater(node) {
        return [...node.children].find(el => el.localName === 'dom-repeat');
        // return [].find.call(node.children, child => {
        //   return child.localName === 'dom-repeat';
        // });
      }
    }

    customElements.define(PolymerSortable.is, PolymerSortable);

    if (!window.PolymerEl) {
      window.PolymerEl = {};
    }

    /*
     * @namespace MultiChart
     */
    window.PolymerEl.PolymerSortable = PolymerSortable;

  })();

  </script>
</dom-module>
